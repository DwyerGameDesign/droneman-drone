/**
 * Drone: The Daily Commute
 * Single Commuter Sprite System
 * Uses full commuter sprites instead of composing from individual parts
 */

class CommuterSpriteSystem {
    constructor(options = {}) {
        // Default options
        this.options = {
            spritesPath: 'assets/sprites/', // Path to the sprites directory
            container: document.getElementById('scene-container'),
            spriteScale: 0.18, // Scale to make commuter appropriate size
            ...options
        };
        
        this.commuters = [];
        
        // Define commuter types - each corresponds to a different sprite image
        this.commuterTypes = [
            { id: 'commuter1', filename: 'commuter1.png' },
            { id: 'commuter2', filename: 'commuter2.png' },
            { id: 'commuter3', filename: 'commuter3.png' },
            { id: 'commuter4', filename: 'commuter4.png' },
            { id: 'commuter5', filename: 'commuter5.png' }
        ];
        
        // Default sprite dimensions - will be scaled accordingly
        this.spriteDimensions = {
            width: 200,
            height: 468
        };
    }
    
    /**
     * Create a commuter sprite
     * @param {Object} options - Configuration for the commuter
     * @returns {Object} - The created commuter object
     */
    createCommuter(options = {}) {
        // Calculate scaled dimensions
        const scale = this.options.spriteScale;
        const scaledWidth = this.spriteDimensions.width * scale;
        const scaledHeight = this.spriteDimensions.height * scale;
        
        // Default commuter options
        const defaultOptions = {
            id: `commuter-${this.commuters.length}`,
            x: 0,
            y: 0, // This will be adjusted to place commuter on platform
            type: Math.floor(Math.random() * this.commuterTypes.length), // Random commuter type
            variant: 'default',
            facingLeft: Math.random() > 0.5,
            hasHat: false, // Will be toggled on later as the first change
            hasBriefcase: Math.random() > 0.5
        };
        
        // Merge with provided options
        const config = this._mergeDeep(defaultOptions, options);
        
        // Get commuter type
        const commuterType = this.commuterTypes[config.type] || this.commuterTypes[0];
        
        // Create the container element
        const commuterElement = document.createElement('div');
        commuterElement.id = config.id;
        commuterElement.className = 'commuter-sprite';
        commuterElement.style.position = 'absolute';
        commuterElement.style.left = `${config.x}px`;
        
        // Bottom positioning - adjust to make commuter stand on platform
        commuterElement.style.bottom = `${config.y}px`;
        
        commuterElement.style.width = `${scaledWidth}px`;
        commuterElement.style.height = `${scaledHeight}px`;
        commuterElement.style.transform = config.facingLeft ? 'scaleX(-1)' : '';
        commuterElement.style.zIndex = '10';
        commuterElement.style.cursor = 'pointer';
        
        // Set up the background image
        const imagePath = `${this.options.spritesPath}${commuterType.filename}`;
        commuterElement.style.backgroundImage = `url(${imagePath})`;
        commuterElement.style.backgroundSize = 'contain';
        commuterElement.style.backgroundRepeat = 'no-repeat';
        commuterElement.style.backgroundPosition = 'bottom center';
        
        // Create accessory elements (hat, briefcase) if needed
        if (config.hasHat) {
            const hatElement = document.createElement('div');
            hatElement.className = 'commuter-hat';
            hatElement.style.position = 'absolute';
            hatElement.style.top = '0';
            hatElement.style.left = '0';
            hatElement.style.width = '100%';
            hatElement.style.height = '30%';
            hatElement.style.backgroundImage = `url(${this.options.spritesPath}hat.png)`;
            hatElement.style.backgroundSize = 'contain';
            hatElement.style.backgroundRepeat = 'no-repeat';
            hatElement.style.backgroundPosition = 'top center';
            hatElement.style.zIndex = '11';
            commuterElement.appendChild(hatElement);
        }
        
        if (config.hasBriefcase) {
            const briefcaseElement = document.createElement('div');
            briefcaseElement.className = 'commuter-briefcase';
            briefcaseElement.style.position = 'absolute';
            briefcaseElement.style.bottom = '30%';
            briefcaseElement.style.left = config.facingLeft ? '60%' : '-20%';
            briefcaseElement.style.width = '40%';
            briefcaseElement.style.height = '20%';
            briefcaseElement.style.backgroundImage = `url(${this.options.spritesPath}briefcase.png)`;
            briefcaseElement.style.backgroundSize = 'contain';
            briefcaseElement.style.backgroundRepeat = 'no-repeat';
            briefcaseElement.style.zIndex = '9';
            commuterElement.appendChild(briefcaseElement);
        }
        
        // Add to container
        if (this.options.container) {
            this.options.container.appendChild(commuterElement);
        }
        
        // Store commuter data
        const commuter = {
            id: config.id,
            element: commuterElement,
            config: config
        };
        
        this.commuters.push(commuter);
        return commuter;
    }
    
    /**
     * Update an existing commuter
     * @param {string} id - ID of the commuter to update
     * @param {Object} options - New configuration options
     */
    updateCommuter(id, options = {}) {
        const commuter = this.commuters.find(c => c.id === id);
        if (!commuter) return null;
        
        // Update commuter attributes
        if ('type' in options) {
            const commuterType = this.commuterTypes[options.type] || this.commuterTypes[0];
            const imagePath = `${this.options.spritesPath}${commuterType.filename}`;
            commuter.element.style.backgroundImage = `url(${imagePath})`;
            commuter.config.type = options.type;
        }
        
        // Update hat visibility
        if ('hasHat' in options) {
            const hatElement = commuter.element.querySelector('.commuter-hat');
            
            if (options.hasHat && !hatElement) {
                // Add hat if it doesn't exist
                const newHatElement = document.createElement('div');
                newHatElement.className = 'commuter-hat';
                newHatElement.style.position = 'absolute';
                newHatElement.style.top = '0';
                newHatElement.style.left = '0';
                newHatElement.style.width = '100%';
                newHatElement.style.height = '30%';
                newHatElement.style.backgroundImage = `url(${this.options.spritesPath}hat.png)`;
                newHatElement.style.backgroundSize = 'contain';
                newHatElement.style.backgroundRepeat = 'no-repeat';
                newHatElement.style.backgroundPosition = 'top center';
                newHatElement.style.zIndex = '11';
                commuter.element.appendChild(newHatElement);
            } else if (!options.hasHat && hatElement) {
                // Remove hat
                hatElement.remove();
            }
            
            commuter.config.hasHat = options.hasHat;
        }
        
        // Update briefcase visibility
        if ('hasBriefcase' in options) {
            const briefcaseElement = commuter.element.querySelector('.commuter-briefcase');
            
            if (options.hasBriefcase && !briefcaseElement) {
                // Add briefcase if it doesn't exist
                const newBriefcaseElement = document.createElement('div');
                newBriefcaseElement.className = 'commuter-briefcase';
                newBriefcaseElement.style.position = 'absolute';
                newBriefcaseElement.style.bottom = '30%';
                newBriefcaseElement.style.left = commuter.config.facingLeft ? '60%' : '-20%';
                newBriefcaseElement.style.width = '40%';
                newBriefcaseElement.style.height = '20%';
                newBriefcaseElement.style.backgroundImage = `url(${this.options.spritesPath}briefcase.png)`;
                newBriefcaseElement.style.backgroundSize = 'contain';
                newBriefcaseElement.style.backgroundRepeat = 'no-repeat';
                newBriefcaseElement.style.zIndex = '9';
                commuter.element.appendChild(newBriefcaseElement);
            } else if (!options.hasBriefcase && briefcaseElement) {
                // Remove briefcase
                briefcaseElement.remove();
            }
            
            commuter.config.hasBriefcase = options.hasBriefcase;
        }
        
        // Update position
        if ('x' in options) {
            commuter.element.style.left = `${options.x}px`;
            commuter.config.x = options.x;
        }
        
        if ('y' in options) {
            commuter.element.style.bottom = `${options.y}px`;
            commuter.config.y = options.y;
        }
        
        // Update direction
        if ('facingLeft' in options) {
            commuter.element.style.transform = options.facingLeft ? 'scaleX(-1)' : '';
            
            // Update briefcase position if it exists
            const briefcaseElement = commuter.element.querySelector('.commuter-briefcase');
            if (briefcaseElement) {
                briefcaseElement.style.left = options.facingLeft ? '60%' : '-20%';
            }
            
            commuter.config.facingLeft = options.facingLeft;
        }
        
        return commuter;
    }
    
    /**
     * Make a commuter clickable
     * @param {string} id - ID of the commuter
     * @param {Function} callback - Click handler function
     */
    makeClickable(id, callback) {
        const commuter = this.commuters.find(c => c.id === id);
        if (commuter) {
            commuter.element.addEventListener('click', (event) => {
                event.stopPropagation();
                callback(commuter, event);
            });
        }
    }
    
    /**
     * Remove a commuter from the scene
     * @param {string} id - ID of the commuter to remove
     */
    removeCommuter(id) {
        const commuter = this.commuters.find(c => c.id === id);
        if (commuter) {
            if (commuter.element.parentNode) {
                commuter.element.parentNode.removeChild(commuter.element);
            }
            this.commuters = this.commuters.filter(c => c.id !== id);
        }
    }
    
    /**
     * Deep merge two objects
     * @private
     */
    _mergeDeep(target, source) {
        const output = Object.assign({}, target);
        
        if (this._isObject(target) && this._isObject(source)) {
            Object.keys(source).forEach(key => {
                if (this._isObject(source[key])) {
                    if (!(key in target)) {
                        Object.assign(output, { [key]: source[key] });
                    } else {
                        output[key] = this._mergeDeep(target[key], source[key]);
                    }
                } else {
                    Object.assign(output, { [key]: source[key] });
                }
            });
        }
        
        return output;
    }
    
    /**
     * Check if value is an object
     * @private
     */
    _isObject(item) {
        return (item && typeof item === 'object' && !Array.isArray(item));
    }
}